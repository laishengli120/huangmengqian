<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é»„æ¢¦èŠŠçš„æ”¾æ˜ å®¤</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a0a, #1a1a1a);
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(145deg, rgba(20, 20, 30, 0.95), rgba(40, 40, 50, 0.9));
            padding: 25px;
            border-radius: 15px;
            color: white;
            z-index: 100;
            min-width: 320px;
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 100, 100, 0.3);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .control-panel.hidden {
            transform: translateX(-100%);
            opacity: 0;
        }
        
        .control-panel h3 {
            margin-bottom: 20px;
            color: #ff6b6b;
            text-align: center;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
            letter-spacing: 1px;
        }
        
        .video-input {
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 107, 107, 0.2);
        }
        
        .video-input label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #ff9999;
            font-weight: 600;
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        
        .file-input {
            display: none;
        }
        
        .file-input-button {
            display: block;
            width: 100%;
            padding: 12px;
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        
        .file-input-button:hover {
            background: linear-gradient(45deg, #ee5a52, #dd4b39);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        .file-name {
            margin-top: 8px;
            font-size: 12px;
            color: #ccc;
            word-break: break-all;
        }
        
        .controls {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 107, 107, 0.3);
        }
        
        .control-row {
            margin-bottom: 8px;
            font-size: 13px;
            display: flex;
            align-items: center;
        }
        
        .control-key {
            background: rgba(255, 107, 107, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            margin-right: 8px;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }
        
        .toggle-ui-btn {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            z-index: 101;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .toggle-ui-btn:hover {
            background: linear-gradient(45deg, #ee5a52, #dd4b39);
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        .audio-controls {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 107, 107, 0.2);
        }
        
        .audio-controls h4 {
            color: #ff9999;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .volume-control {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .volume-control label {
            min-width: 60px;
            font-size: 12px;
            color: #ccc;
        }
        
        .volume-slider {
            flex: 1;
            margin: 0 10px;
            -webkit-appearance: none;
            height: 5px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            outline: none;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: #ff6b6b;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .volume-value {
            min-width: 30px;
            font-size: 12px;
            color: #ff9999;
        }
        
        .mute-btn {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid rgba(255, 107, 107, 0.4);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }
        
        .mute-btn:hover {
            background: rgba(255, 107, 107, 0.4);
        }
        
        .mute-btn.muted {
            background: rgba(255, 0, 0, 0.6);
        }
        
        .loading {
            display: none;
            text-align: center;
            margin-top: 10px;
        }
        
        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 107, 107, 0.3);
            border-top: 2px solid #ff6b6b;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .instructions-title {
            color: #ff6b6b;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
        }
        
        .status-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(145deg, rgba(20, 20, 30, 0.95), rgba(40, 40, 50, 0.9));
            padding: 15px;
            border-radius: 15px;
            color: white;
            z-index: 100;
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 100, 100, 0.3);
            min-width: 200px;
            transition: all 0.3s ease;
        }
        
        .status-panel.hidden {
            transform: translateX(100%);
            opacity: 0;
        }
        
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(145deg, rgba(20, 20, 30, 0.95), rgba(40, 40, 50, 0.9));
            padding: 20px;
            border-radius: 15px;
            color: #ccc;
            z-index: 100;
            font-size: 13px;
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 100, 100, 0.3);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            max-width: 320px;
            transition: all 0.3s ease;
        }
        
        .instructions.hidden {
            transform: translateY(100%);
            opacity: 0;
            pointer-events: none;
        }

        /* --- NEW: è™šæ‹Ÿæ‘‡æ†æ ·å¼ --- */
        #joystick-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 99;
            transition: all 0.3s ease;
        }

        #joystick-container.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #joystick-base {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        #joystick-handle {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: transform 0.1s;
        }

    </style>
</head>
<body>
    <div id="container"></div>
    
    <button class="toggle-ui-btn" onclick="toggleUI()">ğŸ›ï¸ åˆ‡æ¢ç•Œé¢</button>
    
    <div class="control-panel" id="controlPanel">
        <h3>ğŸ¬ è±ªåæ”¾æ˜ å®¤æ§åˆ¶å°</h3>
        
        <div class="video-input">
            <label>ğŸ¥ ä¸»å±å¹•è§†é¢‘:</label>
            <div class="file-input-wrapper">
                <input type="file" id="video1" class="file-input" accept="video/*">
                <label for="video1" class="file-input-button">é€‰æ‹©è§†é¢‘æ–‡ä»¶</label>
                <div class="file-name" id="filename1"></div>
            </div>
        </div>
        
        <div class="video-input">
            <label>ğŸ“º å·¦ä¾§å±å¹•è§†é¢‘:</label>
            <div class="file-input-wrapper">
                <input type="file" id="video2" class="file-input" accept="video/*">
                <label for="video2" class="file-input-button">é€‰æ‹©è§†é¢‘æ–‡ä»¶</label>
                <div class="file-name" id="filename2"></div>
            </div>
        </div>
        
        <div class="video-input">
            <label>ğŸ“» å³ä¾§å±å¹•è§†é¢‘:</label>
            <div class="file-input-wrapper">
                <input type="file" id="video3" class="file-input" accept="video/*">
                <label for="video3" class="file-input-button">é€‰æ‹©è§†é¢‘æ–‡ä»¶</label>
                <div class="file-name" id="filename3"></div>
            </div>
        </div>
        
        <div class="audio-controls">
            <h4>ğŸ”Š éŸ³é¢‘æ§åˆ¶</h4>
            <div class="volume-control">
                <label>ä¸»éŸ³é‡:</label>
                <input type="range" class="volume-slider" id="masterVolume" min="0" max="1" step="0.1" value="0.8">
                <span class="volume-value" id="masterVolumeValue">80%</span>
                <button class="mute-btn" id="masterMute" onclick="toggleMasterMute()">ğŸ”‡</button>
            </div>
            <div class="volume-control">
                <label>ä¸»å±:</label>
                <input type="range" class="volume-slider" id="volume1" min="0" max="1" step="0.1" value="0.8">
                <span class="volume-value" id="volumeValue1">80%</span>
                <button class="mute-btn" id="mute1" onclick="toggleMute(0)">ğŸ”‡</button>
            </div>
            <div class="volume-control">
                <label>å·¦å±:</label>
                <input type="range" class="volume-slider" id="volume2" min="0" max="1" step="0.1" value="0.8">
                <span class="volume-value" id="volumeValue2">80%</span>
                <button class="mute-btn" id="mute2" onclick="toggleMute(1)">ğŸ”‡</button>
            </div>
            <div class="volume-control">
                <label>å³å±:</label>
                <input type="range" class="volume-slider" id="volume3" min="0" max="1" step="0.1" value="0.8">
                <span class="volume-value" id="volumeValue3">80%</span>
                <button class="mute-btn" id="mute3" onclick="toggleMute(2)">ğŸ”‡</button>
            </div>
        </div>
        
        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <div>åŠ è½½ä¸­...</div>
        </div>
        
        <div class="controls">
            <div class="control-row">
                <div class="control-key">ç©ºæ ¼</div>æ’­æ”¾/æš‚åœä¸»å±
            </div>
            <div class="control-row">
                <div class="control-key">1/2/3</div>åˆ‡æ¢å±å¹•ç„¦ç‚¹
            </div>
            <div class="control-row">
                <div class="control-key">H</div>éšè—/æ˜¾ç¤ºç•Œé¢
            </div>
            <div class="control-row">
                <div class="control-key">F</div>å…¨å±æ¨¡å¼
            </div>
            <div class="control-row">
                <div class="control-key">L</div>åˆ‡æ¢ç¯å…‰
            </div>
            <div class="control-row">
                <div class="control-key">M</div>é™éŸ³/å–æ¶ˆé™éŸ³
            </div>
        </div>
    </div>
    
    <div class="status-panel" id="statusPanel">
        <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 10px;">ğŸ­ æ”¾æ˜ çŠ¶æ€</div>
        <div id="status-main">ä¸»å±: å¾…åŠ è½½</div>
        <div id="status-left">å·¦å±: å¾…åŠ è½½</div>
        <div id="status-right">å³å±: å¾…åŠ è½½</div>
        <div style="margin-top: 10px; font-size: 12px; color: #ccc;">
            ç§»åŠ¨é€Ÿåº¦: <span id="speed-display">ä¸­ç­‰</span>
        </div>
        <div style="font-size: 12px; color: #ccc;">
            éŸ³é‡: <span id="master-volume-display">80%</span>
        </div>
    </div>
    
    <div class="instructions" id="instructions">
        <div class="instructions-title">ğŸ® æ“ä½œæŒ‡å—</div>
        <div>ğŸ–±ï¸ æ‹–æ‹½: ç¯è§†å››å‘¨</div>
        <div>æ–æ¡¿/WASD: è‡ªç”±ç§»åŠ¨</div>
        <div>ğŸ–±ï¸ <b>å•å‡»</b>å±å¹•: åˆ‡æ¢ç„¦ç‚¹</div>
        <div>ğŸ–±ï¸ <b>åŒå‡»</b>å±å¹•: æ’­æ”¾/æš‚åœ</div>
        <div>ğŸ“¹ æ‹–æ‹½è§†é¢‘åˆ°å±å¹•æ’­æ”¾</div>
        <div>ğŸ”„ æ»šè½®: è°ƒæ•´ç§»åŠ¨é€Ÿåº¦</div>
        <div>ğŸª Hé”®éšè—ç•Œé¢ï¼Œäº«å—æ²‰æµ¸ä½“éªŒ</div>
    </div>

    <div id="joystick-container">
        <div id="joystick-base">
            <div id="joystick-handle"></div>
        </div>
    </div>
    
    <script>
        // åœºæ™¯åŸºç¡€è®¾ç½®
        let scene, camera, renderer;
        let videos = [];
        let videoTextures = [];
        let screens = [];
        let projectors = [];
        let curtains = [];
        let moveSpeed = 0.1;
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        let cameraRotation = { x: 0, y: 0 };
        let lightsOn = true;
        let ambientLight, mainLight, cinemaLights = [];
        let uiVisible = true;
        let masterVolume = 0.8;
        let isMasterMuted = false;
        let videoMuted = [false, false, false];
        let db;
        // --- NEW: ç”¨äºåŒºåˆ†å•å‡»å’ŒåŒå‡»çš„å˜é‡ ---
        let clickTimeout = null;
        let lastClickedTarget = null;
        let touchTimeout = null;
        let lastTouchedTarget = null;
        // --- NEW: æ‘‡æ†ç›¸å…³å˜é‡ ---
        let joystickVector = new THREE.Vector2(0, 0);
        let joystickActive = false;
        let joystickContainer, joystickBase, joystickHandle;
        let joystickBaseRect;
        let joystickRadius;

        // é”®ç›˜çŠ¶æ€
        const keys = {
            w: false, a: false, s: false, d: false,
            ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false
        };
        
        init();
        animate();
        
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 1, 100);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 8);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x000000, 1);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // åˆå§‹åŒ–æ•°æ®åº“å¹¶åŠ è½½å·²ä¿å­˜çš„è§†é¢‘
            initDB();
            
            // åˆ›å»ºè±ªåæ”¾æ˜ å®¤ç¯å¢ƒ
            createLuxuryCinemaRoom();
            
            // åˆ›å»ºå±å¹•å’Œå¹•å¸ƒ
            createScreensAndCurtains();
            
            // åˆ›å»ºæ”¾æ˜ æœº
            createProjectors();
            
            // æ·»åŠ è±ªåç¯å…‰
            addCinemaLights();
            
            // è®¾ç½®æ§åˆ¶
            setupControls();
            
            // è®¾ç½®æ–‡ä»¶ä¸Šä¼ ç›‘å¬
            setupFileUploads();
            setupJoystick();
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
        }
        
        function initDB() {
            const request = indexedDB.open('VR_Cinema_DB', 1);

            request.onupgradeneeded = function(event) {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('videos')) {
                    db.createObjectStore('videos', { keyPath: 'id' });
                }
            };

            request.onsuccess = function(event) {
                db = event.target.result;
                console.log('æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸ');
                loadVideosFromDB();
            };

            request.onerror = function(event) {
                console.error('æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', event.target.errorCode);
            };
        }

        function saveVideoToDB(index, file) {
            if (!db) return;
            const transaction = db.transaction(['videos'], 'readwrite');
            const store = transaction.objectStore('videos');
            const request = store.put({ id: index, name: file.name, blob: file });
            request.onsuccess = function() {
                console.log(`è§†é¢‘ ${index} (${file.name}) å·²ä¿å­˜åˆ°æ•°æ®åº“`);
            };
            request.onerror = function(event) {
                console.error('è§†é¢‘ä¿å­˜å¤±è´¥:', event.target.errorCode);
            };
        }

        function loadVideosFromDB() {
            if (!db) return;
            const transaction = db.transaction(['videos'], 'readonly');
            const store = transaction.objectStore('videos');
            for (let i = 0; i < 3; i++) {
                const request = store.get(i);
                request.onsuccess = function(event) {
                    const result = event.target.result;
                    if (result && result.blob) {
                        console.log(`ä»æ•°æ®åº“åŠ è½½è§†é¢‘ ${i}:`, result.name);
                        loadVideoFile(result.blob, i, false); // falseè¡¨ç¤ºä¸ä¿å­˜ï¼Œå› ä¸ºå®ƒå·²ç»åœ¨äº†
                    }
                };
            }
        }
        
        function createLuxuryCinemaRoom() {
            // è±ªååœ°æ¯¯
            const floorGeometry = new THREE.PlaneGeometry(35, 35);
            const floorTexture = createCarpetTexture();
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                map: floorTexture,
                transparent: true,
                opacity: 0.9
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // è£…é¥°å¤©èŠ±æ¿
            const ceilingGeometry = new THREE.PlaneGeometry(35, 35);
            const ceilingMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x1a1a2e,
                transparent: true,
                opacity: 0.8
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 10;
            scene.add(ceiling);
            
            // è£…é¥°æ€§å¤©èŠ±æ¿ç¯å¸¦
            for (let i = -10; i <= 10; i += 5) {
                const lightStrip = new THREE.Mesh(
                    new THREE.BoxGeometry(30, 0.2, 0.5),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x333366,
                        emissive: 0x111133
                    })
                );
                lightStrip.position.set(0, 9.5, i);
                scene.add(lightStrip);
            }
            
            // è±ªåå¢™å£
            const wallGeometry = new THREE.PlaneGeometry(35, 12);
            const wallMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2d1b2e,
                transparent: true,
                opacity: 0.9
            });
            
            // åå¢™ï¼ˆå¸¦è£…é¥°ï¼‰
            const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
            backWall.position.set(0, 4, -17);
            scene.add(backWall);
            
            // æ·»åŠ åå¢™è£…é¥°æ¡
            for (let i = -3; i <= 3; i++) {
                const decoration = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 8, 0.3),
                    new THREE.MeshLambertMaterial({ color: 0x4a3548 })
                );
                decoration.position.set(i * 4, 4, -16.8);
                scene.add(decoration);
            }
            
            // ä¾§å¢™
            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-17, 4, 0);
            scene.add(leftWall);
            
            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(17, 4, 0);
            scene.add(rightWall);
            
            // è±ªååº§æ¤…
            createLuxurySeats();
            
            // æ·»åŠ è£…é¥°æŸ±å­
            createDecorativeColumns();
        }
        
        function createCarpetTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const context = canvas.getContext('2d');
            
            // åˆ›å»ºæ·±çº¢è‰²åœ°æ¯¯çº¹ç†
            const gradient = context.createLinearGradient(0, 0, 512, 512);
            gradient.addColorStop(0, '#4a1426');
            gradient.addColorStop(0.5, '#6b1e3a');
            gradient.addColorStop(1, '#4a1426');
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 512, 512);
            
            // æ·»åŠ å›¾æ¡ˆ
            context.strokeStyle = '#3a0f1f';
            context.lineWidth = 2;
            for (let i = 0; i < 512; i += 64) {
                context.beginPath();
                context.moveTo(i, 0);
                context.lineTo(i, 512);
                context.moveTo(0, i);
                context.lineTo(512, i);
                context.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            return texture;
        }
        
        function createLuxurySeats() {
            const seatGeometry = new THREE.BoxGeometry(1.8, 1.2, 1.2);
            const seatMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B0000,
                transparent: true,
                opacity: 0.9
            });
            
            const backrestGeometry = new THREE.BoxGeometry(1.8, 2.5, 0.3);
            const backrestMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xA52A2A
            });
            
            // åˆ›å»ºå¤šæ’åº§æ¤…
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 6; col++) {
                    const seatGroup = new THREE.Group();
                    
                    // åº§æ¤…ä¸»ä½“
                    const seat = new THREE.Mesh(seatGeometry, seatMaterial);
                    seat.position.y = -0.6;
                    seat.castShadow = true;
                    seat.receiveShadow = true;
                    seatGroup.add(seat);
                    
                    // é èƒŒ
                    const backrest = new THREE.Mesh(backrestGeometry, backrestMaterial);
                    backrest.position.set(0, 0.7, 0.45);
                    backrest.castShadow = true;
                    seatGroup.add(backrest);
                    
                    // æ‰¶æ‰‹
                    const armrestGeometry = new THREE.BoxGeometry(0.2, 1, 1);
                    const armrestMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
                    
                    const leftArmrest = new THREE.Mesh(armrestGeometry, armrestMaterial);
                    leftArmrest.position.set(-0.9, 0, 0);
                    seatGroup.add(leftArmrest);
                    
                    const rightArmrest = new THREE.Mesh(armrestGeometry, armrestMaterial);
                    rightArmrest.position.set(0.9, 0, 0);
                    seatGroup.add(rightArmrest);
                    
                    // å®šä½åº§æ¤…ç»„
                    seatGroup.position.set(
                        (col - 2.5) * 3,
                        -1.5,
                        4 + row * 2.5
                    );
                    
                    scene.add(seatGroup);
                }
            }
        }
        
        function createDecorativeColumns() {
            const columnGeometry = new THREE.CylinderGeometry(0.8, 1, 12, 8);
            const columnMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4a3548,
                transparent: true,
                opacity: 0.8
            });
            
            // å·¦ä¾§è£…é¥°æŸ±
            const leftColumn = new THREE.Mesh(columnGeometry, columnMaterial);
            leftColumn.position.set(-15, 4, -8);
            leftColumn.castShadow = true;
            scene.add(leftColumn);
            
            // å³ä¾§è£…é¥°æŸ±
            const rightColumn = new THREE.Mesh(columnGeometry, columnMaterial);
            rightColumn.position.set(15, 4, -8);
            rightColumn.castShadow = true;
            scene.add(rightColumn);
            
            // æŸ±å¤´è£…é¥°
            [leftColumn, rightColumn].forEach(column => {
                const capital = new THREE.Mesh(
                    new THREE.CylinderGeometry(1.2, 1.2, 1, 8),
                    new THREE.MeshLambertMaterial({ color: 0x6a5568 })
                );
                capital.position.copy(column.position);
                capital.position.y += 6;
                scene.add(capital);
            });
        }
        
        function createScreensAndCurtains() {
            // ä¸»å±å¹•
            const mainScreenGeometry = new THREE.PlaneGeometry(14, 8);
            const mainScreen = new THREE.Mesh(
                mainScreenGeometry,
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            mainScreen.position.set(0, 3.5, -12);
            mainScreen.userData = { index: 0, name: 'ä¸»å±å¹•' };
            scene.add(mainScreen);
            screens.push(mainScreen);
            
            // ä¸»å±å¹•çº¢è‰²å¹•å¸ƒ
            const mainCurtainGeometry = new THREE.PlaneGeometry(16, 12);
            const curtainMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B0000,
                transparent: true,
                opacity: 0.9
            });
            const mainCurtain = new THREE.Mesh(mainCurtainGeometry, curtainMaterial);
            mainCurtain.position.set(0, 4, -12.1);
            scene.add(mainCurtain);
            curtains.push(mainCurtain);
            
            // å·¦å±å¹•
            const leftScreenGeometry = new THREE.PlaneGeometry(10, 6);
            const leftScreen = new THREE.Mesh(
                leftScreenGeometry,
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            leftScreen.position.set(-12, 3.5, -6);
            leftScreen.rotation.y = Math.PI / 6;
            leftScreen.userData = { index: 1, name: 'å·¦å±å¹•' };
            scene.add(leftScreen);
            screens.push(leftScreen);
            
            // å·¦å±å¹•å¹•å¸ƒ
            const leftCurtain = new THREE.Mesh(
                new THREE.PlaneGeometry(12, 8),
                curtainMaterial
            );
            leftCurtain.position.set(-12, 3.5, -6.1);
            leftCurtain.rotation.y = Math.PI / 6;
            scene.add(leftCurtain);
            curtains.push(leftCurtain);
            
            // å³å±å¹•
            const rightScreenGeometry = new THREE.PlaneGeometry(10, 6);
            const rightScreen = new THREE.Mesh(
                rightScreenGeometry,
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            rightScreen.position.set(12, 3.5, -6);
            rightScreen.rotation.y = -Math.PI / 6;
            rightScreen.userData = { index: 2, name: 'å³å±å¹•' };
            scene.add(rightScreen);
            screens.push(rightScreen);
            
            // å³å±å¹•å¹•å¸ƒ
            const rightCurtain = new THREE.Mesh(
                new THREE.PlaneGeometry(12, 8),
                curtainMaterial
            );
            rightCurtain.position.set(12, 3.5, -6.1);
            rightCurtain.rotation.y = -Math.PI / 6;
            scene.add(rightCurtain);
            curtains.push(rightCurtain);
            
            // å±å¹•é‡‘è‰²è¾¹æ¡†
            screens.forEach((screen, index) => {
                const frameGeometry = new THREE.BoxGeometry(
                    screen.geometry.parameters.width + 1,
                    screen.geometry.parameters.height + 1,
                    0.3
                );
                const frameMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xFFD700,
                    metalness: 0.8
                });
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.position.copy(screen.position);
                frame.rotation.copy(screen.rotation);
                frame.position.z -= 0.2;
                frame.castShadow = true;
                scene.add(frame);
            });
        }
        
        function createProjectors() {
            // ä¸»æ”¾æ˜ æœº
            const projectorGroup = new THREE.Group();
            
            // æœºèº«
            const bodyGeometry = new THREE.BoxGeometry(3, 1.5, 2);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            projectorGroup.add(body);
            
            // é•œå¤´
            const lensGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16);
            const lensMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x111111,
                transparent: true,
                opacity: 0.8
            });
            const lens = new THREE.Mesh(lensGeometry, lensMaterial);
            lens.rotation.z = Math.PI / 2;
            lens.position.set(-1.5, 0, 0);
            projectorGroup.add(lens);
            
            // æŠ•å½±å…‰æŸæ•ˆæœ
            const beamGeometry = new THREE.ConeGeometry(0.1, 8, 8, 1, true);
            const beamMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            const beam = new THREE.Mesh(beamGeometry, beamMaterial);
            beam.rotation.z = Math.PI / 2;
            beam.position.set(-5, 0, 0);
            projectorGroup.add(beam);
            
            // å®šä½ä¸»æ”¾æ˜ æœº
            projectorGroup.position.set(0, 7, 12);
            projectorGroup.rotation.x = -Math.PI / 12;
            scene.add(projectorGroup);
            projectors.push(projectorGroup);
            
            // ä¾§é¢æ”¾æ˜ æœº
            const leftProjector = projectorGroup.clone();
            leftProjector.position.set(-8, 6, 8);
            leftProjector.rotation.set(-Math.PI / 12, Math.PI / 6, 0);
            scene.add(leftProjector);
            projectors.push(leftProjector);
            
            const rightProjector = projectorGroup.clone();
            rightProjector.position.set(8, 6, 8);
            rightProjector.rotation.set(-Math.PI / 12, -Math.PI / 6, 0);
            scene.add(rightProjector);
            projectors.push(rightProjector);
        }
        
        function addCinemaLights() {
            // æŸ”å’Œç¯å¢ƒå…‰
            ambientLight = new THREE.AmbientLight(0x2c1810, 0.3);
            scene.add(ambientLight);
            
            // ä¸»è¦ç…§æ˜
            mainLight = new THREE.DirectionalLight(0xffd4a3, 0.6);
            mainLight.position.set(0, 15, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 50;
            mainLight.shadow.camera.left = -20;
            mainLight.shadow.camera.right = 20;
            mainLight.shadow.camera.top = 20;
            mainLight.shadow.camera.bottom = -20;
            scene.add(mainLight);
            
            // å±å¹•èƒŒå…‰
            screens.forEach((screen, index) => {
                const screenLight = new THREE.PointLight(0x6666ff, 0.4, 20);
                screenLight.position.copy(screen.position);
                screenLight.position.z += 3;
                scene.add(screenLight);
                cinemaLights.push(screenLight);
            });
            
            // è£…é¥°æ€§ç‚¹å…‰æº
            const decorativeLights = [
                { pos: [-15, 6, -8], color: 0xff6b6b },
                { pos: [15, 6, -8], color: 0xff6b6b },
                { pos: [0, 8, 10], color: 0x4ecdc4 }
            ];
            
            decorativeLights.forEach(lightInfo => {
                const light = new THREE.PointLight(lightInfo.color, 0.3, 15);
                light.position.set(...lightInfo.pos);
                scene.add(light);
                cinemaLights.push(light);
            });
            
            // å¤©èŠ±æ¿ç­’ç¯
            for (let x = -12; x <= 12; x += 8) {
                for (let z = -8; z <= 8; z += 8) {
                    const ceilingLight = new THREE.SpotLight(0xffffff, 0.2, 10, Math.PI / 6, 0.5);
                    ceilingLight.position.set(x, 9, z);
                    ceilingLight.target.position.set(x, 0, z);
                    ceilingLight.castShadow = true;
                    scene.add(ceilingLight);
                    scene.add(ceilingLight.target);
                    cinemaLights.push(ceilingLight);
                }
            }
        }
        
        function setupControls() {
            // é¼ æ ‡æ§åˆ¶
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            
            // é”®ç›˜æ§åˆ¶
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // è§¦æ‘¸æ§åˆ¶æ”¯æŒ
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd);
            
            // æ‹–æ‹½ä¸Šä¼ 
            renderer.domElement.addEventListener('dragover', onDragOver);
            renderer.domElement.addEventListener('drop', onDrop);
        }
        
        function setupFileUploads() {
            for (let i = 1; i <= 3; i++) {
                const fileInput = document.getElementById(`video${i}`);
                const volumeSlider = document.getElementById(`volume${i}`);
                const volumeValue = document.getElementById(`volumeValue${i}`);
                
                fileInput.addEventListener('change', function(event) {
                    const file = event.target.files[0];
                    if (file) {
                        if (file.type.startsWith('video/')) {
                            loadVideoFile(file, i - 1, true);
                        } else {
                            alert('è¯·é€‰æ‹©è§†é¢‘æ–‡ä»¶ï¼');
                        }
                    }
                });
                
                // éŸ³é‡æ§åˆ¶
                volumeSlider.addEventListener('input', function() {
                    const volume = parseFloat(this.value);
                    volumeValue.textContent = Math.round(volume * 100) + '%';
                    if (videos[i - 1]) {
                        updateVideoVolume(i - 1);
                    }
                });
            }
            
            // ä¸»éŸ³é‡æ§åˆ¶
            const masterVolumeSlider = document.getElementById('masterVolume');
            const masterVolumeValue = document.getElementById('masterVolumeValue');
            const masterVolumeDisplay = document.getElementById('master-volume-display');
            
            masterVolumeSlider.addEventListener('input', function() {
                masterVolume = parseFloat(this.value);
                masterVolumeValue.textContent = Math.round(masterVolume * 100) + '%';
                masterVolumeDisplay.textContent = Math.round(masterVolume * 100) + '%';
                
                // æ›´æ–°æ‰€æœ‰è§†é¢‘éŸ³é‡
                videos.forEach((video, index) => {
                    if (video) updateVideoVolume(index);
                });
            });
        }
        
        function loadVideoFile(fileOrBlob, index, shouldSave = true) {
            showLoading(true);
            updateStatus(index, 'åŠ è½½ä¸­...');
            
            const filenameDiv = document.getElementById(`filename${index + 1}`);
            filenameDiv.textContent = `å·²é€‰æ‹©: ${fileOrBlob.name}`;

            if (shouldSave) {
                saveVideoToDB(index, fileOrBlob);
            }
            
            const video = document.createElement('video');
            video.loop = true;
            video.muted = false; // å¯ç”¨å£°éŸ³
            video.playsInline = true;
            video.crossOrigin = 'anonymous';
            video.controls = false; // éšè—é»˜è®¤æ§ä»¶
            
            // è®¾ç½®åˆå§‹éŸ³é‡
            video.volume = masterVolume * parseFloat(document.getElementById(`volume${index + 1}`).value);
            
            video.addEventListener('loadeddata', () => {
                const texture = new THREE.VideoTexture(video);
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.format = THREE.RGBFormat;
                
                // åº”ç”¨çº¹ç†åˆ°å±å¹•
                screens[index].material.dispose();
                screens[index].material = new THREE.MeshBasicMaterial({ 
                    map: texture,
                    side: THREE.FrontSide
                });
                
                // å­˜å‚¨è§†é¢‘å¼•ç”¨
                videos[index] = video;
                videoTextures[index] = texture;
                
                updateStatus(index, 'å·²åŠ è½½');
                showLoading(false);
                
                console.log(`è§†é¢‘ ${index + 1} åŠ è½½æˆåŠŸ:`, fileOrBlob.name);
                
                // è‡ªåŠ¨æ’­æ”¾ç¬¬ä¸€ä¸ªè§†é¢‘ï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’åæ‰èƒ½æœ‰å£°éŸ³ï¼‰
                if (index === 0) {
                    enableAudioContext();
                }
                // // è‡ªåŠ¨æ’­æ”¾åŠ è½½çš„è§†é¢‘
                // video.play().catch(e => console.log("æ’­æ”¾éœ€è¦ç”¨æˆ·äº¤äº’"));
                // updateStatus(index, 'æ’­æ”¾ä¸­');
            });
            
            video.addEventListener('error', (e) => {
                console.error('è§†é¢‘åŠ è½½é”™è¯¯:', e);
                updateStatus(index, 'åŠ è½½å¤±è´¥');
                showLoading(false);
                alert(`è§†é¢‘ ${index + 1} åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼`);
            });
            
            // éŸ³é‡æ”¹å˜äº‹ä»¶
            video.addEventListener('volumechange', () => {
                console.log(`è§†é¢‘ ${index + 1} éŸ³é‡å˜æ›´:`, video.volume);
            });
            
            // åˆ›å»ºå¯¹è±¡URL
            const videoURL = URL.createObjectURL(fileOrBlob);
            video.src = videoURL;
            video.load();
        }
        
        // å¯ç”¨éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆç°ä»£æµè§ˆå™¨éœ€è¦ç”¨æˆ·äº¤äº’ï¼‰
        function enableAudioContext() {
            document.addEventListener('click', function enableAudio() {
                videos.forEach(video => {
                    if (video && video.paused) {
                        video.muted = false;
                    }
                });
                document.removeEventListener('click', enableAudio);
            }, { once: true });
        }
        
        function updateVideoVolume(index) {
            if (videos[index]) {
                const volumeSlider = document.getElementById(`volume${index + 1}`);
                const individualVolume = parseFloat(volumeSlider.value);
                const finalVolume = isMasterMuted || videoMuted[index] ? 0 : masterVolume * individualVolume;
                videos[index].volume = finalVolume;
                
                console.log(`è§†é¢‘ ${index + 1} éŸ³é‡è®¾ç½®ä¸º:`, finalVolume);
            }
        }
        
        function toggleMasterMute() {
            isMasterMuted = !isMasterMuted;
            const muteBtn = document.getElementById('masterMute');
            
            if (isMasterMuted) {
                muteBtn.textContent = 'ğŸ”‡';
                muteBtn.classList.add('muted');
            } else {
                muteBtn.textContent = 'ğŸ”Š';
                muteBtn.classList.remove('muted');
            }
            
            // æ›´æ–°æ‰€æœ‰è§†é¢‘éŸ³é‡
            videos.forEach((video, index) => {
                if (video) updateVideoVolume(index);
            });
        }
        
        function toggleMute(index) {
            videoMuted[index] = !videoMuted[index];
            const muteBtn = document.getElementById(`mute${index + 1}`);
            
            if (videoMuted[index]) {
                muteBtn.textContent = 'ğŸ”‡';
                muteBtn.classList.add('muted');
            } else {
                muteBtn.textContent = 'ğŸ”Š';
                muteBtn.classList.remove('muted');
            }
            
            updateVideoVolume(index);
        }
        
        function toggleUI() {
            uiVisible = !uiVisible;
            const controlPanel = document.getElementById('controlPanel');
            const statusPanel = document.getElementById('statusPanel');
            const instructions = document.getElementById('instructions');
            
            if (uiVisible) {
                controlPanel.classList.remove('hidden');
                statusPanel.classList.remove('hidden');
                instructions.classList.remove('hidden');
            } else {
                controlPanel.classList.add('hidden');
                statusPanel.classList.add('hidden');
                instructions.classList.add('hidden');
            }
        }
        
        function updateStatus(index, status) {
            const statusElements = ['status-main', 'status-left', 'status-right'];
            const screenNames = ['ä¸»å±', 'å·¦å±', 'å³å±'];
            document.getElementById(statusElements[index]).textContent = `${screenNames[index]}: ${status}`;
        }
        
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }
        
        // --- NEW: æ‘‡æ†æ§åˆ¶é€»è¾‘ ---
        function setupJoystick() {
            joystickContainer = document.getElementById('joystick-container');
            joystickBase = document.getElementById('joystick-base');
            joystickHandle = document.getElementById('joystick-handle');
            joystickRadius = joystickBase.offsetWidth / 4;

            joystickHandle.addEventListener('mousedown', startJoystick);
            window.addEventListener('mousemove', moveJoystick);
            window.addEventListener('mouseup', endJoystick);

            joystickHandle.addEventListener('touchstart', startJoystick, { passive: false });
            window.addEventListener('touchmove', moveJoystick, { passive: false });
            window.addEventListener('touchend', endJoystick);
        }

        function startJoystick(event) {
            event.preventDefault();
            joystickActive = true;
            joystickBaseRect = joystickBase.getBoundingClientRect();
        }

        function moveJoystick(event) {
            if (!joystickActive) return;
            event.preventDefault();

            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            const centerX = joystickBaseRect.left + joystickBaseRect.width / 2;
            const centerY = joystickBaseRect.top + joystickBaseRect.height / 2;

            let dx = clientX - centerX;
            let dy = clientY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > joystickRadius) {
                dx = (dx / distance) * joystickRadius;
                dy = (dy / distance) * joystickRadius;
            }
            
            joystickHandle.style.transform = `translate(${dx}px, ${dy}px)`;

            joystickVector.set(dx / joystickRadius, dy / joystickRadius);
        }

        function endJoystick() {
            if (!joystickActive) return;
            joystickActive = false;
            joystickHandle.style.transform = 'translate(0, 0)';
            joystickVector.set(0, 0);
        }

        // --- (é¼ æ ‡ã€è§¦æ‘¸ã€é”®ç›˜ç­‰äº‹ä»¶å¤„ç†å‡½æ•°ä¿æŒä¸å˜ï¼Œé™¤äº† onMouseClick) ---
        function onMouseDown(event) {
            // åªåœ¨é UI å…ƒç´ ä¸Šè§¦å‘æ‹–æ‹½
            if (event.target === renderer.domElement) {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        }
        
        function onMouseMove(event) {
            if (!isMouseDown) return;
            
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            cameraRotation.y -= deltaX * 0.005;
            cameraRotation.x -= deltaY * 0.005;
            cameraRotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, cameraRotation.x));
            
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onMouseUp() {
            isMouseDown = false;
        }
        
        // --- MODIFIED: å®ç°å•å‡»/åŒå‡»åŠŸèƒ½ ---
        function onMouseClick(event) {
            // å¦‚æœé¼ æ ‡æ‹–æ‹½äº†ï¼Œåˆ™ä¸è§¦å‘ç‚¹å‡»äº‹ä»¶
            if (Math.abs(event.clientX - mouseX) > 2 || Math.abs(event.clientY - mouseY) > 2) {
                return;
            }

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(screens);

            if (intersects.length > 0) {
                const clickedScreen = intersects[0].object;
                
                if (clickTimeout && lastClickedTarget === clickedScreen) {
                    // --- åŒå‡»é€»è¾‘ ---
                    clearTimeout(clickTimeout);
                    clickTimeout = null;
                    lastClickedTarget = null;
                    toggleVideo(clickedScreen.userData.index);
                } else {
                    // --- å•å‡»é€»è¾‘ ---
                    clearTimeout(clickTimeout); // å¦‚æœç‚¹å‡»äº†ä¸åŒç›®æ ‡ï¼Œå–æ¶ˆä¸Šä¸€ä¸ªè®¡æ—¶å™¨
                    lastClickedTarget = clickedScreen;
                    clickTimeout = setTimeout(() => {
                        focusOnScreen(clickedScreen.userData.index);
                        clickTimeout = null;
                        lastClickedTarget = null;
                    }, 250); // 250æ¯«ç§’å†…å†æ¬¡ç‚¹å‡»è§†ä¸ºåŒå‡»
                }
            }
        }
        
        function onMouseWheel(event) {
            event.preventDefault();
            const delta = event.deltaY * -0.001;
            moveSpeed = Math.max(0.05, Math.min(0.8, moveSpeed + delta));
            
            const speedText = moveSpeed < 0.15 ? 'æ…¢é€Ÿ' : moveSpeed < 0.35 ? 'ä¸­ç­‰' : 'å¿«é€Ÿ';
            document.getElementById('speed-display').textContent = speedText;
        }

        function onDragOver(event) {
            event.preventDefault();
        }

        function onDrop(event) {
            event.preventDefault();

            const file = event.dataTransfer.files[0];
            if (!file || !file.type.startsWith('video/')) {
                console.log('æ‹–æ‹½çš„ä¸æ˜¯è§†é¢‘æ–‡ä»¶');
                return;
            }

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(screens);

            if (intersects.length > 0) {
                const screen = intersects[0].object;
                const index = screen.userData.index;
                console.log(`è§†é¢‘æ–‡ä»¶å·²æ‹–æ‹½åˆ°å±å¹• ${index}`);
                loadVideoFile(file, index, true);
            }
        }
        
        // è§¦æ‘¸æ§åˆ¶
        let touchStartX = 0, touchStartY = 0;
        
        function onTouchStart(event) {
            // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œå¦‚é¡µé¢æ»šåŠ¨
            if (event.target === renderer.domElement) {
                event.preventDefault();
            }

            // æ£€æŸ¥æ˜¯å¦æ˜¯æ‘‡æ†ä¸Šçš„è§¦æ‘¸
            if (joystickHandle.contains(event.target)) {
                startJoystick(event);
                return;
            }
            
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                // è®°å½•åˆå§‹è§¦æ‘¸ä½ç½®å’Œæ—¶é—´ï¼Œç”¨äºåŒºåˆ†æ‹–æ‹½å’Œç‚¹å‡»
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                isMouseDown = true; // ç”¨äºè§†è§’æ‹–æ‹½
            }
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            if (!isMouseDown || event.touches.length !== 1) return;
            
            const deltaX = event.touches[0].clientX - touchStartX;
            const deltaY = event.touches[0].clientY - touchStartY;
            
            cameraRotation.y -= deltaX * 0.01;
            cameraRotation.x -= deltaY * 0.01;
            cameraRotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, cameraRotation.x));
            
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        }
        
        function onTouchEnd(event) {
            if (joystickActive) {
                endJoystick();
                return;
            }

            if (!isMouseDown) return;
            isMouseDown = false;

            const touch = event.changedTouches[0];

            // 1. åˆ¤æ–­æ˜¯å¦ä¸ºâ€œç‚¹å‡»â€è€Œéâ€œæ‹–æ‹½â€
            // è®¡ç®—è§¦æ‘¸å¼€å§‹å’Œç»“æŸä¹‹é—´çš„è·ç¦»
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            // å¦‚æœç§»åŠ¨è·ç¦»è¿‡å¤§ï¼Œåˆ™è§†ä¸ºæ‹–æ‹½ï¼Œä¸æ‰§è¡Œç‚¹å‡»é€»è¾‘
            if (distance > 10) {
                return;
            }

            // 2. æ‰§è¡Œä¸ onMouseClick ç±»ä¼¼çš„å•å‡»/åŒå‡»åˆ¤æ–­é€»è¾‘
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(screens);

            if (intersects.length > 0) {
                const tappedScreen = intersects[0].object;
                
                // åˆ¤æ–­æ˜¯å¦ä¸ºåŒå‡»
                if (touchTimeout && lastTappedTarget === tappedScreen) {
                    // --- åŒå‡»é€»è¾‘ ---
                    clearTimeout(touchTimeout);
                    touchTimeout = null;
                    lastTappedTarget = null;
                    toggleVideo(tappedScreen.userData.index); // æ’­æ”¾/æš‚åœ
                } else {
                    // --- å•å‡»é€»è¾‘ ---
                    clearTimeout(touchTimeout);
                    lastTappedTarget = tappedScreen;
                    touchTimeout = setTimeout(() => {
                        focusOnScreen(tappedScreen.userData.index); // åˆ‡æ¢ç„¦ç‚¹
                        touchTimeout = null;
                        lastTappedTarget = null;
                    }, 250); // 250æ¯«ç§’å†…å†æ¬¡ç‚¹å‡»è§†ä¸ºåŒå‡»
                }
            }
        }
        
        function onKeyDown(event) {
            const key = event.code.replace('Key', '').toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
            }
            if (keys.hasOwnProperty(event.code)) {
                keys[event.code] = true;
            }
            
            switch(event.code) {
                case 'Space':
                    event.preventDefault();
                    toggleVideo(0); // ç©ºæ ¼é”®ä»ç„¶æ§åˆ¶ä¸»å±å¹•
                    break;
                case 'Digit1':
                    focusOnScreen(0);
                    break;
                case 'Digit2':
                    focusOnScreen(1);
                    break;
                case 'Digit3':
                    focusOnScreen(2);
                    break;
                case 'KeyH':
                    toggleUI();
                    break;
                case 'KeyF':
                    toggleFullscreen();
                    break;
                case 'KeyL':
                    toggleLights();
                    break;
                case 'KeyM':
                    toggleMasterMute();
                    break;
            }
        }
        
        function onKeyUp(event) {
            const key = event.code.replace('Key', '').toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }
            if (keys.hasOwnProperty(event.code)) {
                keys[event.code] = false;
            }
        }
        
        function toggleVideo(index) {
            if (videos[index]) {
                if (videos[index].paused) {
                    videos[index].play().then(() => {
                        updateStatus(index, 'æ’­æ”¾ä¸­');
                    }).catch(e => {
                        console.error('æ’­æ”¾å¤±è´¥:', e);
                        updateStatus(index, 'æ’­æ”¾å¤±è´¥');
                    });
                } else {
                    videos[index].pause();
                    updateStatus(index, 'å·²æš‚åœ');
                }
            } else {
                alert(`è¯·å…ˆä¸º${['ä¸»å±å¹•', 'å·¦å±å¹•', 'å³å±å¹•'][index]}é€‰æ‹©è§†é¢‘æ–‡ä»¶`);
            }
        }
        
        function focusOnScreen(index) {
            const screen = screens[index];
            if (screen) {
                const targetPosition = screen.position.clone();
                const offset = new THREE.Vector3(0, 0, 6);
                offset.applyQuaternion(screen.quaternion);
                targetPosition.add(offset);
                
                animateCamera(targetPosition, screen.position);
            }
        }
        
        function animateCamera(targetPos, lookAtPos) {
            const startPos = camera.position.clone();
            const startLookAt = new THREE.Vector3(0, 0, -1);
            startLookAt.applyQuaternion(camera.quaternion).add(camera.position);
            
            let progress = 0;
            const duration = 60; // frames
            
            function animate() {
                progress++;
                const t = Math.min(progress / duration, 1);
                const easeT = t * t * (3 - 2 * t); // smoothstep
                
                camera.position.lerpVectors(startPos, targetPos, easeT);
                
                const currentLookAt = new THREE.Vector3().lerpVectors(startLookAt, lookAtPos, easeT);
                camera.lookAt(currentLookAt);
                
                if (t < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // åŠ¨ç”»ç»“æŸååŒæ­¥ç›¸æœºæ—‹è½¬çŠ¶æ€
                    const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                    cameraRotation.y = euler.y;
                    cameraRotation.x = euler.x;
                }
            }
            animate();
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        function toggleLights() {
            lightsOn = !lightsOn;
            const intensity = lightsOn ? 1 : 0.3;
            
            ambientLight.intensity = lightsOn ? 0.3 : 0.1;
            mainLight.intensity = lightsOn ? 0.6 : 0.2;
            
            cinemaLights.forEach(light => {
                light.intensity *= intensity / (lightsOn ? 0.3 : 1);
            });
        }
        
        function updateMovement() {
            const moveVector = new THREE.Vector3();
            const speed = moveSpeed;
            
            // --- MODIFIED: ç»“åˆé”®ç›˜å’Œæ‘‡æ†è¾“å…¥ ---
            const moveDirection = new THREE.Vector2(joystickVector.x, -joystickVector.y); // Yè½´åè½¬
            if (keys.w || keys.ArrowUp) moveDirection.y = 1;
            if (keys.s || keys.ArrowDown) moveDirection.y = -1;
            if (keys.a || keys.ArrowLeft) moveDirection.x = -1;
            if (keys.d || keys.ArrowRight) moveDirection.x = 1;

            moveVector.z -= moveDirection.y * speed;
            moveVector.x += moveDirection.x * speed;
            
            moveVector.applyQuaternion(camera.quaternion);
            camera.position.add(moveVector);
            
            // é™åˆ¶ç›¸æœºç§»åŠ¨èŒƒå›´
            camera.position.x = Math.max(-15, Math.min(15, camera.position.x));
            camera.position.z = Math.max(-10, Math.min(15, camera.position.z));
            camera.position.y = Math.max(0.5, Math.min(8, camera.position.y));
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // æ›´æ–°ç›¸æœºæ—‹è½¬
            const quatX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), cameraRotation.x);
            const quatY = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), cameraRotation.y);
            camera.quaternion.copy(quatY).multiply(quatX);

            // æ›´æ–°ç§»åŠ¨
            updateMovement();
            
            // æ›´æ–°è§†é¢‘çº¹ç†
            videoTextures.forEach(texture => {
                if (texture && texture.image && !texture.image.paused) {
                    texture.needsUpdate = true;
                }
            });
            
            // åŠ¨æ€å…‰æ•ˆ
            const time = Date.now() * 0.001;
            cinemaLights.forEach((light, index) => {
                if (light.isPointLight) {
                    light.intensity = 0.3 + Math.sin(time + index) * 0.1;
                }
            });
            
            // å¹•å¸ƒè½»å¾®æ‘†åŠ¨æ•ˆæœ
            curtains.forEach((curtain, index) => {
                curtain.rotation.z = Math.sin(time * 0.5 + index) * 0.02;
            });
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // --- NEW: æ›´æ–°æ‘‡æ†ä½ç½®ä¿¡æ¯ ---
            if (joystickBase) {
                joystickBaseRect = joystickBase.getBoundingClientRect();
            }
        }
        
        // æ€§èƒ½ä¼˜åŒ–
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        // é”™è¯¯å¤„ç†
        window.addEventListener('error', function(e) {
            console.error('åº”ç”¨é”™è¯¯:', e.error);
        });
        
        console.log('ğŸ¬ è±ªåVRæ”¾æ˜ å®¤åˆå§‹åŒ–å®Œæˆï¼');
        console.log('ğŸ“± æ”¯æŒæ¡Œé¢å’Œç§»åŠ¨è®¾å¤‡æ“ä½œ');
        console.log('ğŸ’¾ ä¸Šæ¬¡æ’­æ”¾çš„è§†é¢‘å°†è‡ªåŠ¨åŠ è½½');
    </script>
</body>
</html>
