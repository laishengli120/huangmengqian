<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÈªÑÊ¢¶ËääÁöÑÊîæÊò†ÂÆ§</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a0a, #1a1a1a);
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(145deg, rgba(20, 20, 30, 0.95), rgba(40, 40, 50, 0.9));
            padding: 25px;
            border-radius: 15px;
            color: white;
            z-index: 100;
            min-width: 320px;
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 100, 100, 0.3);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .control-panel.hidden {
            transform: translateX(-100%);
            opacity: 0;
        }
        
        .control-panel h3 {
            margin-bottom: 20px;
            color: #ff6b6b;
            text-align: center;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
            letter-spacing: 1px;
        }
        
        .video-input {
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 107, 107, 0.2);
        }
        
        .video-input label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #ff9999;
            font-weight: 600;
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        
        .file-input {
            display: none;
        }
        
        .file-input-button {
            display: block;
            width: 100%;
            padding: 12px;
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        
        .file-input-button:hover {
            background: linear-gradient(45deg, #ee5a52, #dd4b39);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        .file-name {
            margin-top: 8px;
            font-size: 12px;
            color: #ccc;
            word-break: break-all;
        }
        
        .controls {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 107, 107, 0.3);
        }
        
        .control-row {
            margin-bottom: 8px;
            font-size: 13px;
            display: flex;
            align-items: center;
        }
        
        .control-key {
            background: rgba(255, 107, 107, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            margin-right: 8px;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }
        
        .toggle-ui-btn {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            z-index: 101;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .toggle-ui-btn:hover {
            background: linear-gradient(45deg, #ee5a52, #dd4b39);
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        .audio-controls {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 107, 107, 0.2);
        }
        
        .audio-controls h4 {
            color: #ff9999;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .volume-control {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .volume-control label {
            min-width: 60px;
            font-size: 12px;
            color: #ccc;
        }
        
        .volume-slider {
            flex: 1;
            margin: 0 10px;
            -webkit-appearance: none;
            height: 5px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            outline: none;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: #ff6b6b;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .volume-value {
            min-width: 30px;
            font-size: 12px;
            color: #ff9999;
        }
        
        .mute-btn {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid rgba(255, 107, 107, 0.4);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }
        
        .mute-btn:hover {
            background: rgba(255, 107, 107, 0.4);
        }
        
        .mute-btn.muted {
            background: rgba(255, 0, 0, 0.6);
        }
        
        .loading {
            display: none;
            text-align: center;
            margin-top: 10px;
        }
        
        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 107, 107, 0.3);
            border-top: 2px solid #ff6b6b;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .instructions-title {
            color: #ff6b6b;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
        }
        
        .status-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(145deg, rgba(20, 20, 30, 0.95), rgba(40, 40, 50, 0.9));
            padding: 15px;
            border-radius: 15px;
            color: white;
            z-index: 100;
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 100, 100, 0.3);
            min-width: 200px;
            transition: all 0.3s ease;
        }
        
        .status-panel.hidden {
            transform: translateX(100%);
            opacity: 0;
        }
        
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(145deg, rgba(20, 20, 30, 0.95), rgba(40, 40, 50, 0.9));
            padding: 20px;
            border-radius: 15px;
            color: #ccc;
            z-index: 100;
            font-size: 13px;
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 100, 100, 0.3);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            max-width: 320px;
            transition: all 0.3s ease;
        }
        
        .instructions.hidden {
            transform: translateY(100%);
            opacity: 0;
            pointer-events: none;
        }

        /* --- NEW: ËôöÊãüÊëáÊùÜÊ†∑Âºè --- */
        #joystick-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 99;
            transition: all 0.3s ease;
        }

        #joystick-container.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #joystick-base {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        #joystick-handle {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: transform 0.1s;
        }

    </style>
</head>
<body>
    <div id="container"></div>
    
    <button class="toggle-ui-btn" onclick="toggleUI()">üéõÔ∏è ÂàáÊç¢ÁïåÈù¢</button>
    
    <div class="control-panel" id="controlPanel">
        <h3>üé¨ Ë±™ÂçéÊîæÊò†ÂÆ§ÊéßÂà∂Âè∞</h3>
        
        <div class="video-input">
            <label>üé• ‰∏ªÂ±èÂπïËßÜÈ¢ë:</label>
            <div class="file-input-wrapper">
                <input type="file" id="video1" class="file-input" accept="video/*">
                <label for="video1" class="file-input-button">ÈÄâÊã©ËßÜÈ¢ëÊñá‰ª∂</label>
                <div class="file-name" id="filename1"></div>
            </div>
        </div>
        
        <div class="video-input">
            <label>üì∫ Â∑¶‰æßÂ±èÂπïËßÜÈ¢ë:</label>
            <div class="file-input-wrapper">
                <input type="file" id="video2" class="file-input" accept="video/*">
                <label for="video2" class="file-input-button">ÈÄâÊã©ËßÜÈ¢ëÊñá‰ª∂</label>
                <div class="file-name" id="filename2"></div>
            </div>
        </div>
        
        <div class="video-input">
            <label>üìª Âè≥‰æßÂ±èÂπïËßÜÈ¢ë:</label>
            <div class="file-input-wrapper">
                <input type="file" id="video3" class="file-input" accept="video/*">
                <label for="video3" class="file-input-button">ÈÄâÊã©ËßÜÈ¢ëÊñá‰ª∂</label>
                <div class="file-name" id="filename3"></div>
            </div>
        </div>
        
        <div class="audio-controls">
            <h4>üîä Èü≥È¢ëÊéßÂà∂</h4>
            <div class="volume-control">
                <label>‰∏ªÈü≥Èáè:</label>
                <input type="range" class="volume-slider" id="masterVolume" min="0" max="1" step="0.1" value="0.8">
                <span class="volume-value" id="masterVolumeValue">80%</span>
                <button class="mute-btn" id="masterMute" onclick="toggleMasterMute()">üîá</button>
            </div>
            <div class="volume-control">
                <label>‰∏ªÂ±è:</label>
                <input type="range" class="volume-slider" id="volume1" min="0" max="1" step="0.1" value="0.8">
                <span class="volume-value" id="volumeValue1">80%</span>
                <button class="mute-btn" id="mute1" onclick="toggleMute(0)">üîá</button>
            </div>
            <div class="volume-control">
                <label>Â∑¶Â±è:</label>
                <input type="range" class="volume-slider" id="volume2" min="0" max="1" step="0.1" value="0.8">
                <span class="volume-value" id="volumeValue2">80%</span>
                <button class="mute-btn" id="mute2" onclick="toggleMute(1)">üîá</button>
            </div>
            <div class="volume-control">
                <label>Âè≥Â±è:</label>
                <input type="range" class="volume-slider" id="volume3" min="0" max="1" step="0.1" value="0.8">
                <span class="volume-value" id="volumeValue3">80%</span>
                <button class="mute-btn" id="mute3" onclick="toggleMute(2)">üîá</button>
            </div>
        </div>
        
        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <div>Âä†ËΩΩ‰∏≠...</div>
        </div>
        
        <div class="controls">
            <div class="control-row">
                <div class="control-key">Á©∫Ê†º</div>Êí≠Êîæ/ÊöÇÂÅú‰∏ªÂ±è
            </div>
            <div class="control-row">
                <div class="control-key">1/2/3</div>ÂàáÊç¢Â±èÂπïÁÑ¶ÁÇπ
            </div>
            <div class="control-row">
                <div class="control-key">H</div>ÈöêËóè/ÊòæÁ§∫ÁïåÈù¢
            </div>
            <div class="control-row">
                <div class="control-key">F</div>ÂÖ®Â±èÊ®°Âºè
            </div>
            <div class="control-row">
                <div class="control-key">L</div>ÂàáÊç¢ÁÅØÂÖâ
            </div>
            <div class="control-row">
                <div class="control-key">M</div>ÈùôÈü≥/ÂèñÊ∂àÈùôÈü≥
            </div>
        </div>
    </div>
    
    <div class="status-panel" id="statusPanel">
        <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 10px;">üé≠ ÊîæÊò†Áä∂ÊÄÅ</div>
        <div id="status-main">‰∏ªÂ±è: ÂæÖÂä†ËΩΩ</div>
        <div id="status-left">Â∑¶Â±è: ÂæÖÂä†ËΩΩ</div>
        <div id="status-right">Âè≥Â±è: ÂæÖÂä†ËΩΩ</div>
        <div style="margin-top: 10px; font-size: 12px; color: #ccc;">
            ÁßªÂä®ÈÄüÂ∫¶: <span id="speed-display">‰∏≠Á≠â</span>
        </div>
        <div style="font-size: 12px; color: #ccc;">
            Èü≥Èáè: <span id="master-volume-display">80%</span>
        </div>
    </div>
    
    <div class="instructions" id="instructions">
        <div class="instructions-title">üéÆ Êìç‰ΩúÊåáÂçó</div>
        <div>üñ±Ô∏è ÊãñÊãΩ: ÁéØËßÜÂõõÂë®</div>
        <div>ÊêñÊ°ø/WASD: Ëá™Áî±ÁßªÂä®</div>
        <div>üñ±Ô∏è <b>ÂçïÂáª</b>Â±èÂπï: ÂàáÊç¢ÁÑ¶ÁÇπ</div>
        <div>üñ±Ô∏è <b>ÂèåÂáª</b>Â±èÂπï: Êí≠Êîæ/ÊöÇÂÅú</div>
        <div>üìπ ÊãñÊãΩËßÜÈ¢ëÂà∞Â±èÂπïÊí≠Êîæ</div>
        <div>üîÑ ÊªöËΩÆ: Ë∞ÉÊï¥ÁßªÂä®ÈÄüÂ∫¶</div>
        <div>üé™ HÈîÆÈöêËóèÁïåÈù¢Ôºå‰∫´ÂèóÊ≤âÊµ∏‰ΩìÈ™å</div>
    </div>

    <div id="joystick-container">
        <div id="joystick-base">
            <div id="joystick-handle"></div>
        </div>
    </div>
    
    <script>
        // Âú∫ÊôØÂü∫Á°ÄËÆæÁΩÆ
        let scene, camera, renderer;
        let videos = [];
        let videoTextures = [];
        let screens = [];
        let projectors = [];
        let curtains = [];
        let moveSpeed = 0.1;
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        let cameraRotation = { x: 0, y: 0 };
        let lightsOn = true;
        let ambientLight, mainLight, cinemaLights = [];
        let uiVisible = true;
        let masterVolume = 0.8;
        let isMasterMuted = false;
        let videoMuted = [false, false, false];
        let db;
        // --- NEW: Áî®‰∫éÂå∫ÂàÜÂçïÂáªÂíåÂèåÂáªÁöÑÂèòÈáè ---
        let clickTimeout = null;
        let lastClickedTarget = null;
        let touchTimeout = null;
        let lastTouchedTarget = null;
        // --- NEW: ÊëáÊùÜÁõ∏ÂÖ≥ÂèòÈáè ---
        let joystickVector = new THREE.Vector2(0, 0);
        let joystickActive = false;
        let joystickContainer, joystickBase, joystickHandle;
        let joystickBaseRect;
        let joystickRadius;

        // ÈîÆÁõòÁä∂ÊÄÅ
        const keys = {
            w: false, a: false, s: false, d: false,
            ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false
        };
        
        init();
        animate();
        
        function init() {
            // ÂàõÂª∫Âú∫ÊôØ
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 1, 100);
            
            // ÂàõÂª∫Áõ∏Êú∫
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 8);
            
            // ÂàõÂª∫Ê∏≤ÊüìÂô®
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x000000, 1);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ìÂπ∂Âä†ËΩΩÂ∑≤‰øùÂ≠òÁöÑËßÜÈ¢ë
            initDB();
            
            // ÂàõÂª∫Ë±™ÂçéÊîæÊò†ÂÆ§ÁéØÂ¢É
            createLuxuryCinemaRoom();
            
            // ÂàõÂª∫Â±èÂπïÂíåÂπïÂ∏É
            createScreensAndCurtains();
            
            // ÂàõÂª∫ÊîæÊò†Êú∫
            createProjectors();
            
            // Ê∑ªÂä†Ë±™ÂçéÁÅØÂÖâ
            addCinemaLights();
            
            // ËÆæÁΩÆÊéßÂà∂
            setupControls();
            
            // ËÆæÁΩÆÊñá‰ª∂‰∏ä‰º†ÁõëÂê¨
            setupFileUploads();
            setupJoystick();
            // Á™óÂè£Â§ßÂ∞èË∞ÉÊï¥
            window.addEventListener('resize', onWindowResize);
        }
        
        function initDB() {
            const request = indexedDB.open('VR_Cinema_DB', 1);

            request.onupgradeneeded = function(event) {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('videos')) {
                    db.createObjectStore('videos', { keyPath: 'id' });
                }
            };

            request.onsuccess = function(event) {
                db = event.target.result;
                console.log('Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñÊàêÂäü');
                loadVideosFromDB();
            };

            request.onerror = function(event) {
                console.error('Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂ§±Ë¥•:', event.target.errorCode);
            };
        }

        function saveVideoToDB(index, file) {
            if (!db) return;
            const transaction = db.transaction(['videos'], 'readwrite');
            const store = transaction.objectStore('videos');
            const request = store.put({ id: index, name: file.name, blob: file });
            request.onsuccess = function() {
                console.log(`ËßÜÈ¢ë ${index} (${file.name}) Â∑≤‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì`);
            };
            request.onerror = function(event) {
                console.error('ËßÜÈ¢ë‰øùÂ≠òÂ§±Ë¥•:', event.target.errorCode);
            };
        }

        function loadVideosFromDB() {
            if (!db) return;
            const transaction = db.transaction(['videos'], 'readonly');
            const store = transaction.objectStore('videos');
            for (let i = 0; i < 3; i++) {
                const request = store.get(i);
                request.onsuccess = function(event) {
                    const result = event.target.result;
                    if (result && result.blob) {
                        console.log(`‰ªéÊï∞ÊçÆÂ∫ìÂä†ËΩΩËßÜÈ¢ë ${i}:`, result.name);
                        loadVideoFile(result.blob, i, false); // falseË°®Á§∫‰∏ç‰øùÂ≠òÔºåÂõ†‰∏∫ÂÆÉÂ∑≤ÁªèÂú®‰∫Ü
                    }
                };
            }
        }
        
        function createLuxuryCinemaRoom() {
            // Ë±™ÂçéÂú∞ÊØØ
            const floorGeometry = new THREE.PlaneGeometry(35, 35);
            const floorTexture = createCarpetTexture();
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                map: floorTexture,
                transparent: true,
                opacity: 0.9
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Ë£ÖÈ•∞Â§©Ëä±Êùø
            const ceilingGeometry = new THREE.PlaneGeometry(35, 35);
            const ceilingMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x1a1a2e,
                transparent: true,
                opacity: 0.8
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 10;
            scene.add(ceiling);
            
            // Ë£ÖÈ•∞ÊÄßÂ§©Ëä±ÊùøÁÅØÂ∏¶
            for (let i = -10; i <= 10; i += 5) {
                const lightStrip = new THREE.Mesh(
                    new THREE.BoxGeometry(30, 0.2, 0.5),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x333366,
                        emissive: 0x111133
                    })
                );
                lightStrip.position.set(0, 9.5, i);
                scene.add(lightStrip);
            }
            
            // Ë±™ÂçéÂ¢ôÂ£Å
            const wallGeometry = new THREE.PlaneGeometry(35, 12);
            const wallMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2d1b2e,
                transparent: true,
                opacity: 0.9
            });
            
            // ÂêéÂ¢ôÔºàÂ∏¶Ë£ÖÈ•∞Ôºâ
            const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
            backWall.position.set(0, 4, -17);
            scene.add(backWall);
            
            // Ê∑ªÂä†ÂêéÂ¢ôË£ÖÈ•∞Êù°
            for (let i = -3; i <= 3; i++) {
                const decoration = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 8, 0.3),
                    new THREE.MeshLambertMaterial({ color: 0x4a3548 })
                );
                decoration.position.set(i * 4, 4, -16.8);
                scene.add(decoration);
            }
            
            // ‰æßÂ¢ô
            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-17, 4, 0);
            scene.add(leftWall);
            
            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(17, 4, 0);
            scene.add(rightWall);
            
            // Ë±™ÂçéÂ∫ßÊ§Ö
            createLuxurySeats();
            
            // Ê∑ªÂä†Ë£ÖÈ•∞Êü±Â≠ê
            createDecorativeColumns();
        }
        
        function createCarpetTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const context = canvas.getContext('2d');
            
            // ÂàõÂª∫Ê∑±Á∫¢Ëâ≤Âú∞ÊØØÁ∫πÁêÜ
            const gradient = context.createLinearGradient(0, 0, 512, 512);
            gradient.addColorStop(0, '#4a1426');
            gradient.addColorStop(0.5, '#6b1e3a');
            gradient.addColorStop(1, '#4a1426');
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 512, 512);
            
            // Ê∑ªÂä†ÂõæÊ°à
            context.strokeStyle = '#3a0f1f';
            context.lineWidth = 2;
            for (let i = 0; i < 512; i += 64) {
                context.beginPath();
                context.moveTo(i, 0);
                context.lineTo(i, 512);
                context.moveTo(0, i);
                context.lineTo(512, i);
                context.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            return texture;
        }
        
        function createLuxurySeats() {
            const seatGeometry = new THREE.BoxGeometry(1.8, 1.2, 1.2);
            const seatMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B0000,
                transparent: true,
                opacity: 0.9
            });
            
            const backrestGeometry = new THREE.BoxGeometry(1.8, 2.5, 0.3);
            const backrestMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xA52A2A
            });
            
            // ÂàõÂª∫Â§öÊéíÂ∫ßÊ§Ö
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 6; col++) {
                    const seatGroup = new THREE.Group();
                    
                    // Â∫ßÊ§Ö‰∏ª‰Ωì
                    const seat = new THREE.Mesh(seatGeometry, seatMaterial);
                    seat.position.y = -0.6;
                    seat.castShadow = true;
                    seat.receiveShadow = true;
                    seatGroup.add(seat);
                    
                    // Èù†ËÉå
                    const backrest = new THREE.Mesh(backrestGeometry, backrestMaterial);
                    backrest.position.set(0, 0.7, 0.45);
                    backrest.castShadow = true;
                    seatGroup.add(backrest);
                    
                    // Êâ∂Êâã
                    const armrestGeometry = new THREE.BoxGeometry(0.2, 1, 1);
                    const armrestMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
                    
                    const leftArmrest = new THREE.Mesh(armrestGeometry, armrestMaterial);
                    leftArmrest.position.set(-0.9, 0, 0);
                    seatGroup.add(leftArmrest);
                    
                    const rightArmrest = new THREE.Mesh(armrestGeometry, armrestMaterial);
                    rightArmrest.position.set(0.9, 0, 0);
                    seatGroup.add(rightArmrest);
                    
                    // ÂÆö‰ΩçÂ∫ßÊ§ÖÁªÑ
                    seatGroup.position.set(
                        (col - 2.5) * 3,
                        -1.5,
                        4 + row * 2.5
                    );
                    
                    scene.add(seatGroup);
                }
            }
        }
        
        function createDecorativeColumns() {
            const columnGeometry = new THREE.CylinderGeometry(0.8, 1, 12, 8);
            const columnMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4a3548,
                transparent: true,
                opacity: 0.8
            });
            
            // Â∑¶‰æßË£ÖÈ•∞Êü±
            const leftColumn = new THREE.Mesh(columnGeometry, columnMaterial);
            leftColumn.position.set(-15, 4, -8);
            leftColumn.castShadow = true;
            scene.add(leftColumn);
            
            // Âè≥‰æßË£ÖÈ•∞Êü±
            const rightColumn = new THREE.Mesh(columnGeometry, columnMaterial);
            rightColumn.position.set(15, 4, -8);
            rightColumn.castShadow = true;
            scene.add(rightColumn);
            
            // Êü±Â§¥Ë£ÖÈ•∞
            [leftColumn, rightColumn].forEach(column => {
                const capital = new THREE.Mesh(
                    new THREE.CylinderGeometry(1.2, 1.2, 1, 8),
                    new THREE.MeshLambertMaterial({ color: 0x6a5568 })
                );
                capital.position.copy(column.position);
                capital.position.y += 6;
                scene.add(capital);
            });
        }
        
        function createScreensAndCurtains() {
            // ‰∏ªÂ±èÂπï
            const mainScreenGeometry = new THREE.PlaneGeometry(14, 8);
            const mainScreen = new THREE.Mesh(
                mainScreenGeometry,
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            mainScreen.position.set(0, 3.5, -12);
            mainScreen.userData = { index: 0, name: '‰∏ªÂ±èÂπï' };
            scene.add(mainScreen);
            screens.push(mainScreen);
            
            // ‰∏ªÂ±èÂπïÁ∫¢Ëâ≤ÂπïÂ∏É
            const mainCurtainGeometry = new THREE.PlaneGeometry(16, 12);
            const curtainMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B0000,
                transparent: true,
                opacity: 0.9
            });
            const mainCurtain = new THREE.Mesh(mainCurtainGeometry, curtainMaterial);
            mainCurtain.position.set(0, 4, -12.1);
            scene.add(mainCurtain);
            curtains.push(mainCurtain);
            
            // Â∑¶Â±èÂπï
            const leftScreenGeometry = new THREE.PlaneGeometry(10, 6);
            const leftScreen = new THREE.Mesh(
                leftScreenGeometry,
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            leftScreen.position.set(-12, 3.5, -6);
            leftScreen.rotation.y = Math.PI / 6;
            leftScreen.userData = { index: 1, name: 'Â∑¶Â±èÂπï' };
            scene.add(leftScreen);
            screens.push(leftScreen);
            
            // Â∑¶Â±èÂπïÂπïÂ∏É
            const leftCurtain = new THREE.Mesh(
                new THREE.PlaneGeometry(12, 8),
                curtainMaterial
            );
            leftCurtain.position.set(-12, 3.5, -6.1);
            leftCurtain.rotation.y = Math.PI / 6;
            scene.add(leftCurtain);
            curtains.push(leftCurtain);
            
            // Âè≥Â±èÂπï
            const rightScreenGeometry = new THREE.PlaneGeometry(10, 6);
            const rightScreen = new THREE.Mesh(
                rightScreenGeometry,
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            rightScreen.position.set(12, 3.5, -6);
            rightScreen.rotation.y = -Math.PI / 6;
            rightScreen.userData = { index: 2, name: 'Âè≥Â±èÂπï' };
            scene.add(rightScreen);
            screens.push(rightScreen);
            
            // Âè≥Â±èÂπïÂπïÂ∏É
            const rightCurtain = new THREE.Mesh(
                new THREE.PlaneGeometry(12, 8),
                curtainMaterial
            );
            rightCurtain.position.set(12, 3.5, -6.1);
            rightCurtain.rotation.y = -Math.PI / 6;
            scene.add(rightCurtain);
            curtains.push(rightCurtain);
            
            // Â±èÂπïÈáëËâ≤ËæπÊ°Ü
            screens.forEach((screen, index) => {
                const frameGeometry = new THREE.BoxGeometry(
                    screen.geometry.parameters.width + 1,
                    screen.geometry.parameters.height + 1,
                    0.3
                );
                const frameMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xFFD700,
                    metalness: 0.8
                });
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.position.copy(screen.position);
                frame.rotation.copy(screen.rotation);
                frame.position.z -= 0.2;
                frame.castShadow = true;
                scene.add(frame);
            });
        }
        
        function createProjectors() {
            // ‰∏ªÊîæÊò†Êú∫
            const projectorGroup = new THREE.Group();
            
            // Êú∫Ë∫´
            const bodyGeometry = new THREE.BoxGeometry(3, 1.5, 2);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            projectorGroup.add(body);
            
            // ÈïúÂ§¥
            const lensGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16);
            const lensMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x111111,
                transparent: true,
                opacity: 0.8
            });
            const lens = new THREE.Mesh(lensGeometry, lensMaterial);
            lens.rotation.z = Math.PI / 2;
            lens.position.set(-1.5, 0, 0);
            projectorGroup.add(lens);
            
            // ÊäïÂΩ±ÂÖâÊùüÊïàÊûú
            const beamGeometry = new THREE.ConeGeometry(0.1, 8, 8, 1, true);
            const beamMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            const beam = new THREE.Mesh(beamGeometry, beamMaterial);
            beam.rotation.z = Math.PI / 2;
            beam.position.set(-5, 0, 0);
            projectorGroup.add(beam);
            
            // ÂÆö‰Ωç‰∏ªÊîæÊò†Êú∫
            projectorGroup.position.set(0, 7, 12);
            projectorGroup.rotation.x = -Math.PI / 12;
            scene.add(projectorGroup);
            projectors.push(projectorGroup);
            
            // ‰æßÈù¢ÊîæÊò†Êú∫
            const leftProjector = projectorGroup.clone();
            leftProjector.position.set(-8, 6, 8);
            leftProjector.rotation.set(-Math.PI / 12, Math.PI / 6, 0);
            scene.add(leftProjector);
            projectors.push(leftProjector);
            
            const rightProjector = projectorGroup.clone();
            rightProjector.position.set(8, 6, 8);
            rightProjector.rotation.set(-Math.PI / 12, -Math.PI / 6, 0);
            scene.add(rightProjector);
            projectors.push(rightProjector);
        }
        
        function addCinemaLights() {
            // ÊüîÂíåÁéØÂ¢ÉÂÖâ
            ambientLight = new THREE.AmbientLight(0x2c1810, 0.3);
            scene.add(ambientLight);
            
            // ‰∏ªË¶ÅÁÖßÊòé
            mainLight = new THREE.DirectionalLight(0xffd4a3, 0.6);
            mainLight.position.set(0, 15, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 50;
            mainLight.shadow.camera.left = -20;
            mainLight.shadow.camera.right = 20;
            mainLight.shadow.camera.top = 20;
            mainLight.shadow.camera.bottom = -20;
            scene.add(mainLight);
            
            // Â±èÂπïËÉåÂÖâ
            screens.forEach((screen, index) => {
                const screenLight = new THREE.PointLight(0x6666ff, 0.4, 20);
                screenLight.position.copy(screen.position);
                screenLight.position.z += 3;
                scene.add(screenLight);
                cinemaLights.push(screenLight);
            });
            
            // Ë£ÖÈ•∞ÊÄßÁÇπÂÖâÊ∫ê
            const decorativeLights = [
                { pos: [-15, 6, -8], color: 0xff6b6b },
                { pos: [15, 6, -8], color: 0xff6b6b },
                { pos: [0, 8, 10], color: 0x4ecdc4 }
            ];
            
            decorativeLights.forEach(lightInfo => {
                const light = new THREE.PointLight(lightInfo.color, 0.3, 15);
                light.position.set(...lightInfo.pos);
                scene.add(light);
                cinemaLights.push(light);
            });
            
            // Â§©Ëä±ÊùøÁ≠íÁÅØ
            for (let x = -12; x <= 12; x += 8) {
                for (let z = -8; z <= 8; z += 8) {
                    const ceilingLight = new THREE.SpotLight(0xffffff, 0.2, 10, Math.PI / 6, 0.5);
                    ceilingLight.position.set(x, 9, z);
                    ceilingLight.target.position.set(x, 0, z);
                    ceilingLight.castShadow = true;
                    scene.add(ceilingLight);
                    scene.add(ceilingLight.target);
                    cinemaLights.push(ceilingLight);
                }
            }
        }
        
        function setupControls() {
            // Èº†Ê†áÊéßÂà∂
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            
            // ÈîÆÁõòÊéßÂà∂
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Ëß¶Êë∏ÊéßÂà∂ÊîØÊåÅ
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd);
            
            // ÊãñÊãΩ‰∏ä‰º†
            renderer.domElement.addEventListener('dragover', onDragOver);
            renderer.domElement.addEventListener('drop', onDrop);
        }
        
        function setupFileUploads() {
            for (let i = 1; i <= 3; i++) {
                const fileInput = document.getElementById(`video${i}`);
                const volumeSlider = document.getElementById(`volume${i}`);
                const volumeValue = document.getElementById(`volumeValue${i}`);
                
                fileInput.addEventListener('change', function(event) {
                    const file = event.target.files[0];
                    if (file) {
                        if (file.type.startsWith('video/')) {
                            loadVideoFile(file, i - 1, true);
                        } else {
                            alert('ËØ∑ÈÄâÊã©ËßÜÈ¢ëÊñá‰ª∂ÔºÅ');
                        }
                    }
                });
                
                // Èü≥ÈáèÊéßÂà∂
                volumeSlider.addEventListener('input', function() {
                    const volume = parseFloat(this.value);
                    volumeValue.textContent = Math.round(volume * 100) + '%';
                    if (videos[i - 1]) {
                        updateVideoVolume(i - 1);
                    }
                });
            }
            
            // ‰∏ªÈü≥ÈáèÊéßÂà∂
            const masterVolumeSlider = document.getElementById('masterVolume');
            const masterVolumeValue = document.getElementById('masterVolumeValue');
            const masterVolumeDisplay = document.getElementById('master-volume-display');
            
            masterVolumeSlider.addEventListener('input', function() {
                masterVolume = parseFloat(this.value);
                masterVolumeValue.textContent = Math.round(masterVolume * 100) + '%';
                masterVolumeDisplay.textContent = Math.round(masterVolume * 100) + '%';
                
                // Êõ¥Êñ∞ÊâÄÊúâËßÜÈ¢ëÈü≥Èáè
                videos.forEach((video, index) => {
                    if (video) updateVideoVolume(index);
                });
            });
        }
        
        function loadVideoFile(fileOrBlob, index, shouldSave = true) {
            showLoading(true);
            updateStatus(index, 'Âä†ËΩΩ‰∏≠...');
            
            const filenameDiv = document.getElementById(`filename${index + 1}`);
            filenameDiv.textContent = `Â∑≤ÈÄâÊã©: ${fileOrBlob.name}`;

            if (shouldSave) {
                saveVideoToDB(index, fileOrBlob);
            }
            
            const video = document.createElement('video');
            video.loop = true;
            video.muted = false; // ÂêØÁî®Â£∞Èü≥
            video.playsInline = true;
            video.crossOrigin = 'anonymous';
            video.controls = false; // ÈöêËóèÈªòËÆ§Êéß‰ª∂
            
            // ËÆæÁΩÆÂàùÂßãÈü≥Èáè
            video.volume = masterVolume * parseFloat(document.getElementById(`volume${index + 1}`).value);
            
            video.addEventListener('loadeddata', () => {
                const texture = new THREE.VideoTexture(video);
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.format = THREE.RGBFormat;
                
                // Â∫îÁî®Á∫πÁêÜÂà∞Â±èÂπï
                screens[index].material.dispose();
                screens[index].material = new THREE.MeshBasicMaterial({ 
                    map: texture,
                    side: THREE.FrontSide
                });
                
                // Â≠òÂÇ®ËßÜÈ¢ëÂºïÁî®
                videos[index] = video;
                videoTextures[index] = texture;
                
                updateStatus(index, 'Â∑≤Âä†ËΩΩ');
                showLoading(false);
                
                console.log(`ËßÜÈ¢ë ${index + 1} Âä†ËΩΩÊàêÂäü:`, fileOrBlob.name);
                
                // Ëá™Âä®Êí≠ÊîæÁ¨¨‰∏Ä‰∏™ËßÜÈ¢ëÔºàÈúÄË¶ÅÁî®Êà∑‰∫§‰∫íÂêéÊâçËÉΩÊúâÂ£∞Èü≥Ôºâ
                if (index === 0) {
                    enableAudioContext();
                }
                // // Ëá™Âä®Êí≠ÊîæÂä†ËΩΩÁöÑËßÜÈ¢ë
                // video.play().catch(e => console.log("Êí≠ÊîæÈúÄË¶ÅÁî®Êà∑‰∫§‰∫í"));
                // updateStatus(index, 'Êí≠Êîæ‰∏≠');
            });
            
            video.addEventListener('error', (e) => {
                console.error('ËßÜÈ¢ëÂä†ËΩΩÈîôËØØ:', e);
                updateStatus(index, 'Âä†ËΩΩÂ§±Ë¥•');
                showLoading(false);
                alert(`ËßÜÈ¢ë ${index + 1} Âä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•Êñá‰ª∂Ê†ºÂºè`);
            });
            
            // Èü≥ÈáèÊîπÂèò‰∫ã‰ª∂
            video.addEventListener('volumechange', () => {
                console.log(`ËßÜÈ¢ë ${index + 1} Èü≥ÈáèÂèòÊõ¥:`, video.volume);
            });
            
            // ÂàõÂª∫ÂØπË±°URL
            const videoURL = URL.createObjectURL(fileOrBlob);
            video.src = videoURL;
            video.load();
        }
        
        // ÂêØÁî®Èü≥È¢ë‰∏ä‰∏ãÊñáÔºàÁé∞‰ª£ÊµèËßàÂô®ÈúÄË¶ÅÁî®Êà∑‰∫§‰∫íÔºâ
        function enableAudioContext() {
            document.addEventListener('click', function enableAudio() {
                videos.forEach(video => {
                    if (video && video.paused) {
                        video.muted = false;
                    }
                });
                document.removeEventListener('click', enableAudio);
            }, { once: true });
        }
        
        function updateVideoVolume(index) {
            if (videos[index]) {
                const volumeSlider = document.getElementById(`volume${index + 1}`);
                const individualVolume = parseFloat(volumeSlider.value);
                const finalVolume = isMasterMuted || videoMuted[index] ? 0 : masterVolume * individualVolume;
                videos[index].volume = finalVolume;
                
                console.log(`ËßÜÈ¢ë ${index + 1} Èü≥ÈáèËÆæÁΩÆ‰∏∫:`, finalVolume);
            }
        }
        
        function toggleMasterMute() {
            isMasterMuted = !isMasterMuted;
            const muteBtn = document.getElementById('masterMute');
            
            if (isMasterMuted) {
                muteBtn.textContent = 'üîá';
                muteBtn.classList.add('muted');
            } else {
                muteBtn.textContent = 'üîä';
                muteBtn.classList.remove('muted');
            }
            
            // Êõ¥Êñ∞ÊâÄÊúâËßÜÈ¢ëÈü≥Èáè
            videos.forEach((video, index) => {
                if (video) updateVideoVolume(index);
            });
        }
        
        function toggleMute(index) {
            videoMuted[index] = !videoMuted[index];
            const muteBtn = document.getElementById(`mute${index + 1}`);
            
            if (videoMuted[index]) {
                muteBtn.textContent = 'üîá';
                muteBtn.classList.add('muted');
            } else {
                muteBtn.textContent = 'üîä';
                muteBtn.classList.remove('muted');
            }
            
            updateVideoVolume(index);
        }
        
        function toggleUI() {
            uiVisible = !uiVisible;
            const controlPanel = document.getElementById('controlPanel');
            const statusPanel = document.getElementById('statusPanel');
            const instructions = document.getElementById('instructions');
            
            if (uiVisible) {
                controlPanel.classList.remove('hidden');
                statusPanel.classList.remove('hidden');
                instructions.classList.remove('hidden');
            } else {
                controlPanel.classList.add('hidden');
                statusPanel.classList.add('hidden');
                instructions.classList.add('hidden');
            }
        }
        
        function updateStatus(index, status) {
            const statusElements = ['status-main', 'status-left', 'status-right'];
            const screenNames = ['‰∏ªÂ±è', 'Â∑¶Â±è', 'Âè≥Â±è'];
            document.getElementById(statusElements[index]).textContent = `${screenNames[index]}: ${status}`;
        }
        
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }
        
        // --- NEW: ÊëáÊùÜÊéßÂà∂ÈÄªËæë ---
        function setupJoystick() {
            joystickContainer = document.getElementById('joystick-container');
            joystickBase = document.getElementById('joystick-base');
            joystickHandle = document.getElementById('joystick-handle');
            joystickRadius = joystickBase.offsetWidth / 4;

            joystickHandle.addEventListener('mousedown', startJoystick);
            window.addEventListener('mousemove', moveJoystick);
            window.addEventListener('mouseup', endJoystick);

            joystickHandle.addEventListener('touchstart', startJoystick, { passive: false });
            window.addEventListener('touchmove', moveJoystick, { passive: false });
            window.addEventListener('touchend', endJoystick);
        }

        function startJoystick(event) {
            event.preventDefault();
            joystickActive = true;
            joystickBaseRect = joystickBase.getBoundingClientRect();
        }

        function moveJoystick(event) {
            if (!joystickActive) return;
            event.preventDefault();

            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            const centerX = joystickBaseRect.left + joystickBaseRect.width / 2;
            const centerY = joystickBaseRect.top + joystickBaseRect.height / 2;

            let dx = clientX - centerX;
            let dy = clientY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > joystickRadius) {
                dx = (dx / distance) * joystickRadius;
                dy = (dy / distance) * joystickRadius;
            }
            
            joystickHandle.style.transform = `translate(${dx}px, ${dy}px)`;

            joystickVector.set(dx / joystickRadius, dy / joystickRadius);
        }

        function endJoystick() {
            if (!joystickActive) return;
            joystickActive = false;
            joystickHandle.style.transform = 'translate(0, 0)';
            joystickVector.set(0, 0);
        }

        // --- (Èº†Ê†á„ÄÅËß¶Êë∏„ÄÅÈîÆÁõòÁ≠â‰∫ã‰ª∂Â§ÑÁêÜÂáΩÊï∞‰øùÊåÅ‰∏çÂèòÔºåÈô§‰∫Ü onMouseClick) ---
        function onMouseDown(event) {
            // Âè™Âú®Èùû UI ÂÖÉÁ¥†‰∏äËß¶ÂèëÊãñÊãΩ
            if (event.target === renderer.domElement) {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        }
        
        function onMouseMove(event) {
            if (!isMouseDown) return;
            
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            cameraRotation.y -= deltaX * 0.005;
            cameraRotation.x -= deltaY * 0.005;
            cameraRotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, cameraRotation.x));
            
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onMouseUp() {
            isMouseDown = false;
        }
        
        // --- MODIFIED: ÂÆûÁé∞ÂçïÂáª/ÂèåÂáªÂäüËÉΩ ---
        function onMouseClick(event) {
            // Â¶ÇÊûúÈº†Ê†áÊãñÊãΩ‰∫ÜÔºåÂàô‰∏çËß¶ÂèëÁÇπÂáª‰∫ã‰ª∂
            if (Math.abs(event.clientX - mouseX) > 2 || Math.abs(event.clientY - mouseY) > 2) {
                return;
            }

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(screens);

            if (intersects.length > 0) {
                const clickedScreen = intersects[0].object;
                
                if (clickTimeout && lastClickedTarget === clickedScreen) {
                    // --- ÂèåÂáªÈÄªËæë ---
                    clearTimeout(clickTimeout);
                    clickTimeout = null;
                    lastClickedTarget = null;
                    toggleVideo(clickedScreen.userData.index);
                } else {
                    // --- ÂçïÂáªÈÄªËæë ---
                    clearTimeout(clickTimeout); // Â¶ÇÊûúÁÇπÂáª‰∫Ü‰∏çÂêåÁõÆÊ†áÔºåÂèñÊ∂à‰∏ä‰∏Ä‰∏™ËÆ°Êó∂Âô®
                    lastClickedTarget = clickedScreen;
                    clickTimeout = setTimeout(() => {
                        focusOnScreen(clickedScreen.userData.index);
                        clickTimeout = null;
                        lastClickedTarget = null;
                    }, 250); // 250ÊØ´ÁßíÂÜÖÂÜçÊ¨°ÁÇπÂáªËßÜ‰∏∫ÂèåÂáª
                }
            }
        }
        
        function onMouseWheel(event) {
            event.preventDefault();
            const delta = event.deltaY * -0.001;
            moveSpeed = Math.max(0.05, Math.min(0.8, moveSpeed + delta));
            
            const speedText = moveSpeed < 0.15 ? 'ÊÖ¢ÈÄü' : moveSpeed < 0.35 ? '‰∏≠Á≠â' : 'Âø´ÈÄü';
            document.getElementById('speed-display').textContent = speedText;
        }

        function onDragOver(event) {
            event.preventDefault();
        }

        function onDrop(event) {
            event.preventDefault();

            const file = event.dataTransfer.files[0];
            if (!file || !file.type.startsWith('video/')) {
                console.log('ÊãñÊãΩÁöÑ‰∏çÊòØËßÜÈ¢ëÊñá‰ª∂');
                return;
            }

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(screens);

            if (intersects.length > 0) {
                const screen = intersects[0].object;
                const index = screen.userData.index;
                console.log(`ËßÜÈ¢ëÊñá‰ª∂Â∑≤ÊãñÊãΩÂà∞Â±èÂπï ${index}`);
                loadVideoFile(file, index, true);
            }
        }
        
        // Ëß¶Êë∏ÊéßÂà∂
        let touchStartX = 0, touchStartY = 0;
        
        function onTouchStart(event) {
            // ÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫ÔºåÂ¶ÇÈ°µÈù¢ÊªöÂä®
            if (event.target === renderer.domElement) {
                event.preventDefault();
            }

            // Ê£ÄÊü•ÊòØÂê¶ÊòØÊëáÊùÜ‰∏äÁöÑËß¶Êë∏
            if (joystickHandle.contains(event.target)) {
                startJoystick(event);
                return;
            }
            
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                // ËÆ∞ÂΩïÂàùÂßãËß¶Êë∏‰ΩçÁΩÆÂíåÊó∂Èó¥ÔºåÁî®‰∫éÂå∫ÂàÜÊãñÊãΩÂíåÁÇπÂáª
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                isMouseDown = true; // Áî®‰∫éËßÜËßíÊãñÊãΩ
            }
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            if (!isMouseDown || event.touches.length !== 1) return;
            
            const deltaX = event.touches[0].clientX - touchStartX;
            const deltaY = event.touches[0].clientY - touchStartY;
            
            cameraRotation.y -= deltaX * 0.01;
            cameraRotation.x -= deltaY * 0.01;
            cameraRotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, cameraRotation.x));
            
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        }
        
        function onTouchEnd(event) {
            if (joystickActive) {
                endJoystick();
                return;
            }

            if (!isMouseDown) return;
            isMouseDown = false;

            const touch = event.changedTouches[0];

            // 1. Âà§Êñ≠ÊòØÂê¶‰∏∫‚ÄúÁÇπÂáª‚ÄùËÄåÈùû‚ÄúÊãñÊãΩ‚Äù
            // ËÆ°ÁÆóËß¶Êë∏ÂºÄÂßãÂíåÁªìÊùü‰πãÈó¥ÁöÑË∑ùÁ¶ª
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            // Â¶ÇÊûúÁßªÂä®Ë∑ùÁ¶ªËøáÂ§ßÔºåÂàôËßÜ‰∏∫ÊãñÊãΩÔºå‰∏çÊâßË°åÁÇπÂáªÈÄªËæë
            if (distance > 10) {
                return;
            }

            // 2. ÊâßË°å‰∏é onMouseClick Á±ª‰ººÁöÑÂçïÂáª/ÂèåÂáªÂà§Êñ≠ÈÄªËæë
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(screens);

            if (intersects.length > 0) {
                const tappedScreen = intersects[0].object;
                
                // Âà§Êñ≠ÊòØÂê¶‰∏∫ÂèåÂáª
                if (touchTimeout && lastTappedTarget === tappedScreen) {
                    // --- ÂèåÂáªÈÄªËæë ---
                    clearTimeout(touchTimeout);
                    touchTimeout = null;
                    lastTappedTarget = null;
                    toggleVideo(tappedScreen.userData.index); // Êí≠Êîæ/ÊöÇÂÅú
                } else {
                    // --- ÂçïÂáªÈÄªËæë ---
                    clearTimeout(touchTimeout);
                    lastTappedTarget = tappedScreen;
                    touchTimeout = setTimeout(() => {
                        focusOnScreen(tappedScreen.userData.index); // ÂàáÊç¢ÁÑ¶ÁÇπ
                        touchTimeout = null;
                        lastTappedTarget = null;
                    }, 250); // 250ÊØ´ÁßíÂÜÖÂÜçÊ¨°ÁÇπÂáªËßÜ‰∏∫ÂèåÂáª
                }
            }
        }
        
        function onKeyDown(event) {
            const key = event.code.replace('Key', '').toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
            }
            if (keys.hasOwnProperty(event.code)) {
                keys[event.code] = true;
            }
            
            switch(event.code) {
                case 'Space':
                    event.preventDefault();
                    toggleVideo(0); // Á©∫Ê†ºÈîÆ‰ªçÁÑ∂ÊéßÂà∂‰∏ªÂ±èÂπï
                    break;
                case 'Digit1':
                    focusOnScreen(0);
                    break;
                case 'Digit2':
                    focusOnScreen(1);
                    break;
                case 'Digit3':
                    focusOnScreen(2);
                    break;
                case 'KeyH':
                    toggleUI();
                    break;
                case 'KeyF':
                    toggleFullscreen();
                    break;
                case 'KeyL':
                    toggleLights();
                    break;
                case 'KeyM':
                    toggleMasterMute();
                    break;
            }
        }
        
        function onKeyUp(event) {
            const key = event.code.replace('Key', '').toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }
            if (keys.hasOwnProperty(event.code)) {
                keys[event.code] = false;
            }
        }
        
        function toggleVideo(index) {
            if (videos[index]) {
                if (videos[index].paused) {
                    videos[index].play().then(() => {
                        updateStatus(index, 'Êí≠Êîæ‰∏≠');
                    }).catch(e => {
                        console.error('Êí≠ÊîæÂ§±Ë¥•:', e);
                        updateStatus(index, 'Êí≠ÊîæÂ§±Ë¥•');
                    });
                } else {
                    videos[index].pause();
                    updateStatus(index, 'Â∑≤ÊöÇÂÅú');
                }
            } else {
                alert(`ËØ∑ÂÖà‰∏∫${['‰∏ªÂ±èÂπï', 'Â∑¶Â±èÂπï', 'Âè≥Â±èÂπï'][index]}ÈÄâÊã©ËßÜÈ¢ëÊñá‰ª∂`);
            }
        }
        
        function focusOnScreen(index) {
            const screen = screens[index];
            if (screen) {
                const targetPosition = screen.position.clone();
                const offset = new THREE.Vector3(0, 0, 6);
                offset.applyQuaternion(screen.quaternion);
                targetPosition.add(offset);
                
                animateCamera(targetPosition, screen.position);
            }
        }
        
        function animateCamera(targetPos, lookAtPos) {
            const startPos = camera.position.clone();
            const startLookAt = new THREE.Vector3(0, 0, -1);
            startLookAt.applyQuaternion(camera.quaternion).add(camera.position);
            
            let progress = 0;
            const duration = 60; // frames
            
            function animate() {
                progress++;
                const t = Math.min(progress / duration, 1);
                const easeT = t * t * (3 - 2 * t); // smoothstep
                
                camera.position.lerpVectors(startPos, targetPos, easeT);
                
                const currentLookAt = new THREE.Vector3().lerpVectors(startLookAt, lookAtPos, easeT);
                camera.lookAt(currentLookAt);
                
                if (t < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Âä®ÁîªÁªìÊùüÂêéÂêåÊ≠•Áõ∏Êú∫ÊóãËΩ¨Áä∂ÊÄÅ
                    const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                    cameraRotation.y = euler.y;
                    cameraRotation.x = euler.x;
                }
            }
            animate();
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        function toggleLights() {
            lightsOn = !lightsOn;
            const intensity = lightsOn ? 1 : 0.3;
            
            ambientLight.intensity = lightsOn ? 0.3 : 0.1;
            mainLight.intensity = lightsOn ? 0.6 : 0.2;
            
            cinemaLights.forEach(light => {
                light.intensity *= intensity / (lightsOn ? 0.3 : 1);
            });
        }
        
        function updateMovement() {
            const moveVector = new THREE.Vector3();
            const speed = moveSpeed;
            
            // --- MODIFIED: ÁªìÂêàÈîÆÁõòÂíåÊëáÊùÜËæìÂÖ• ---
            const moveDirection = new THREE.Vector2(joystickVector.x, -joystickVector.y); // YËΩ¥ÂèçËΩ¨
            if (keys.w || keys.ArrowUp) moveDirection.y = 1;
            if (keys.s || keys.ArrowDown) moveDirection.y = -1;
            if (keys.a || keys.ArrowLeft) moveDirection.x = -1;
            if (keys.d || keys.ArrowRight) moveDirection.x = 1;

            moveVector.z -= moveDirection.y * speed;
            moveVector.x += moveDirection.x * speed;
            
            moveVector.applyQuaternion(camera.quaternion);
            camera.position.add(moveVector);
            
            // ÈôêÂà∂Áõ∏Êú∫ÁßªÂä®ËåÉÂõ¥
            camera.position.x = Math.max(-15, Math.min(15, camera.position.x));
            camera.position.z = Math.max(-10, Math.min(15, camera.position.z));
            camera.position.y = Math.max(0.5, Math.min(8, camera.position.y));
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Êõ¥Êñ∞Áõ∏Êú∫ÊóãËΩ¨
            const quatX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), cameraRotation.x);
            const quatY = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), cameraRotation.y);
            camera.quaternion.copy(quatY).multiply(quatX);

            // Êõ¥Êñ∞ÁßªÂä®
            updateMovement();
            
            // Êõ¥Êñ∞ËßÜÈ¢ëÁ∫πÁêÜ
            videoTextures.forEach(texture => {
                if (texture && texture.image && !texture.image.paused) {
                    texture.needsUpdate = true;
                }
            });
            
            // Âä®ÊÄÅÂÖâÊïà
            const time = Date.now() * 0.001;
            cinemaLights.forEach((light, index) => {
                if (light.isPointLight) {
                    light.intensity = 0.3 + Math.sin(time + index) * 0.1;
                }
            });
            
            // ÂπïÂ∏ÉËΩªÂæÆÊëÜÂä®ÊïàÊûú
            curtains.forEach((curtain, index) => {
                curtain.rotation.z = Math.sin(time * 0.5 + index) * 0.02;
            });
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // --- NEW: Êõ¥Êñ∞ÊëáÊùÜ‰ΩçÁΩÆ‰ø°ÊÅØ ---
            if (joystickBase) {
                joystickBaseRect = joystickBase.getBoundingClientRect();
            }
        }
        
        // ÊÄßËÉΩ‰ºòÂåñ
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        // ÈîôËØØÂ§ÑÁêÜ
        window.addEventListener('error', function(e) {
            console.error('Â∫îÁî®ÈîôËØØ:', e.error);
        });
        
        console.log('üé¨ Ë±™ÂçéVRÊîæÊò†ÂÆ§ÂàùÂßãÂåñÂÆåÊàêÔºÅ');
        console.log('üì± ÊîØÊåÅÊ°åÈù¢ÂíåÁßªÂä®ËÆæÂ§áÊìç‰Ωú');
        console.log('üíæ ‰∏äÊ¨°Êí≠ÊîæÁöÑËßÜÈ¢ëÂ∞ÜËá™Âä®Âä†ËΩΩ');
    </script>
</body>
</html>
